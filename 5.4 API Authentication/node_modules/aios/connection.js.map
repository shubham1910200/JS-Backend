{"version":3,"sources":["../../../src/connection.ts"],"names":[],"mappings":"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","file":"connection.js","sourcesContent":["import {format as f, inherits} from 'util';\nimport * as net from 'net';\nimport {EventEmitter} from 'events';\nimport {Utils} from './utils';\nimport * as _ from 'lodash';\nimport * as actions from './actions';\n\n/**\n * Implements Socket Connection to Aios Server\n */\n\n\nlet _id = 0;\n\n// @ts-ignore\nconst Response = actions.Response;\n\nexport function Connection(options: {\n  debug?: any;\n  messageHandler?: any; maxBsonMessageSize?: any;\n  port?: any; host?: any; keepAlive?: any; keepAliveInitialDelay?: any; noDelay?: any; connectionTimeout?: any; socketTimeout?: any;\n}) {\n\n  options = options || {};\n\n  // Set empty if no options passed\n  this.options = options;\n  // Identification information\n  this.id = _id++;\n  this.debug = options.debug || false;\n\n\n  // Message handler\n  this.messageHandler = options.messageHandler ? options.messageHandler : defaultMessageHandler;\n\n  // Max JSON message size\n  this.maxBsonMessageSize = options.maxBsonMessageSize || (1024 * 1024 * 16 * 4);\n\n\n  // Default options\n  this.port = options.port || 8118;\n  this.host = options.host || 'localhost';\n  this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;\n  this.noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  this.connectionTimeout = options.connectionTimeout || 60000;\n  this.socketTimeout = options.socketTimeout || 60000;\n\n  // Check if we have a domain socket\n  this.domainSocket = this.host.indexOf('\\/') !== -1;\n\n  // Internal state\n  this.connection = null;\n  this.isSync = false;\n  this.callbacks = {};\n}\n\n\nconst defaultMessageHandler = function (buffer: any) {\n  const response = new Response(buffer);\n  response.parse();\n  return response;\n};\n\n\n//\n// Connection handlers\nconst errorHandler = function (sock: { getConnection: () => any; handleError: (arg0: any) => void; }) {\n  return function (err: any) {\n    // Debug information\n    const conn = sock.getConnection();\n    if (conn.debug) {\n      console.trace(f('connection %s for [%s:%s] errored out with [%s]', conn.id, conn.host, conn.port, JSON.stringify(err)));\n    }\n    // Emit the error\n    sock.handleError(err);\n\n  };\n};\n\nconst timeoutHandler = function (self: { getConnection: () => any; handleTimeout: () => void; }) {\n  return function () {\n    // Debug information\n    const conn = self.getConnection();\n    if (conn.debug) {\n      console.trace(f('connection %s for [%s:%s] timed out', conn.id, conn.host, conn.port));\n    }\n    // Emit timeout error\n    self.handleTimeout();\n  };\n};\n\nconst closeHandler = function (self: { getConnection: () => any; handleClose: (arg0: any) => void; }) {\n  return function (hadError: any) {\n    // Debug information\n    const conn = self.getConnection();\n    if (conn.debug) {\n      console.trace(f('connection %s with for [%s:%s] closed', conn.id, conn.host, conn.port));\n    }\n    // Emit close event\n    self.handleClose(hadError);\n  };\n};\n\nconst dataHandler = function (self: any) {\n  return function (data: any) {\n    const maxBsonMessageSize = self.wrapper.maxBsonMessageSize;\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (self.bytesRead > 0 && self.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = self.sizeOfMessage - self.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(self.buffer, self.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          self.bytesRead = self.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = new Buffer(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          try {\n            const emitBuffer = self.buffer;\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n            // Emit the buffer\n            self.handleData(emitBuffer);\n\n          } catch (err) {\n            const errorObject = {\n              err: 'socketHandler',\n              trace: err,\n              bin: self.buffer,\n              parseState: {\n                sizeOfMessage: self.sizeOfMessage,\n                bytesRead: self.bytesRead,\n                stubBuffer: self.stubBuffer\n              }\n            };\n            // We got a parse Error fire it off then keep going\n            self.handleParseError(errorObject);\n          }\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 8 bytes)\n        if (self.stubBuffer != null && self.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (self.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = new Buffer(self.stubBuffer.length + data.length);\n            self.stubBuffer.copy(newData, 0);\n            data.copy(newData, self.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n\n          } else {\n\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = new Buffer(self.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            self.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, self.stubBuffer.length);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        } else {\n          if (data.length > 8) {\n            // Retrieve the message size\n            // var totalLength = data.readUInt32LE(0);\n            // var totalLength = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;\n            // var totalLength = data[0]  | data[1] << 8 | data[2] << 16 | data[3] << 24;\n            const totalLength = Utils.encodeTotalLength(data);\n\n            const sizeOfMessage = totalLength + 8;\n            // If we have a negative totalLength emit error and return\n            if (sizeOfMessage < 0 || sizeOfMessage > maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: self.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: self.bytesRead,\n                  stubBuffer: self.stubBuffer\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              self.handleParseError(errorObject);\n\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if (sizeOfMessage > 8 && sizeOfMessage < maxBsonMessageSize && sizeOfMessage > data.length) {\n              self.buffer = new Buffer(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(self.buffer, 0);\n              // Update bytes read\n              self.bytesRead = data.length;\n              // Update totalLength\n              self.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n\n            } else if (sizeOfMessage > 8 && sizeOfMessage < maxBsonMessageSize && sizeOfMessage === data.length) {\n              try {\n                const emitBuffer = data;\n                // Reset state of buffer\n                self.buffer = null;\n                self.sizeOfMessage = 0;\n                self.bytesRead = 0;\n                self.stubBuffer = null;\n                // Exit parsing loop\n                data = new Buffer(0);\n                // Emit the message\n                self.handleData(emitBuffer);\n\n              } catch (err) {\n                const errorObject = {\n                  err: 'socketHandler',\n                  trace: err,\n                  bin: self.buffer,\n                  parseState: {\n                    sizeOfMessage: sizeOfMessage,\n                    bytesRead: self.bytesRead,\n                    stubBuffer: self.stubBuffer\n                  }\n                };\n                // We got a parse Error fire it off then keep going\n                self.handleParseError(errorObject);\n              }\n            } else if (sizeOfMessage <= 8 || sizeOfMessage > maxBsonMessageSize) {\n              const errorObject: any = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              self.handleParseError(errorObject);\n              // Clear out the state of the parser\n              self.buffer = null;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              self.buffer = null;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              self.handleData(emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            self.stubBuffer = new Buffer(data.length);\n            // Copy the data to the stub buffer\n            data.copy(self.stubBuffer, 0);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        }\n      }\n    }\n  };\n};\n\n\n/**\n *\n * @constructor\n * @param connection\n */\nconst AsyncSock = function (connection: any) {\n  this.wrapper = connection;\n  this.connection = null;\n\n\n  // Add event listener\n  EventEmitter.call(this);\n\n  const self = this;\n\n\n  // Create new connection instance\n  self.connection = self.wrapper.domainSocket\n    ? net.createConnection(self.wrapper.host)\n    : net.createConnection(self.wrapper.port, self.wrapper.host);\n\n  // Set the options for the connection\n  self.connection.setKeepAlive(self.wrapper.keepAlive, self.wrapper.keepAliveInitialDelay);\n  self.connection.setTimeout(self.wrapper.connectionTimeout);\n  self.connection.setNoDelay(self.wrapper.noDelay);\n\n\n  self.connection.on('connect', function () {\n    // Set socket timeout instead of connection timeout\n    self.connection.setTimeout(self.wrapper.socketTimeout);\n    // Emit connect event\n    self.emit('connect', self.wrapper);\n  });\n\n\n  // Add handlers for events\n  self.connection.once('error', errorHandler(self));\n  self.connection.once('timeout', timeoutHandler(self));\n  self.connection.once('close', closeHandler(self));\n  self.connection.on('data', dataHandler(self));\n\n  // copy previous registered callbacks\n  const eventTypes = Object.keys(self.wrapper.callbacks);\n  eventTypes.forEach(function (key) {\n    self.wrapper.callbacks[key].forEach(function (fn: any) {\n      self.on(key, fn);\n    });\n  });\n  self.wrapper.callbacks = {};\n};\n\ninherits(AsyncSock, EventEmitter);\n\nAsyncSock.prototype.emit = function () {\n  const args = Array.prototype.slice.call(arguments);\n  const type = args.shift();\n\n  if (args.length > 0 && _.isError(args[0])) {\n    args.unshift(type);\n  } else {\n    args.unshift(type, undefined);\n  }\n\n  EventEmitter.prototype.emit.apply(this, args);\n};\n\n/* ======================================\n *           Sock getSock\n */\n\n/**\n *\n * @returns {net.Socket}\n */\nAsyncSock.prototype.getSock = function () {\n  if (this.connection) {\n    return this.connection;\n  }\n  return null;\n};\n\n\n/**\n *\n * @returns {Connection}\n */\nAsyncSock.prototype.getConnection = function () {\n  return this.wrapper;\n};\n\n\n/* ======================================\n *           Sock destroy\n */\n\n\nAsyncSock.prototype.destroy = function (fn: any) {\n  if (fn) {\n    this.once('close', fn);\n  }\n\n  if (this.connection) {\n    this.connection.end();\n    // return this.connection.destroy();\n  }\n\n};\n\n/* ======================================\n *           Sock write\n */\n\n\nAsyncSock.prototype.write = function (buffer: any, fn: any) {\n  const self = this;\n\n  if (fn) {\n    self.once('data', fn);\n  }\n\n  // Write out the command\n  // this.connection.write(buffer, 'binary');\n  if (!Array.isArray(buffer)) {\n    return this.connection.write(buffer, 'binary');\n  }\n  // Iterate over all buffers and write them in order to the socket\n  for (let i = 0; i < buffer.length; i++) {\n    this.connection.write(buffer[i], 'binary');\n  }\n};\n\n/* ======================================\n *           Sock isConnected\n */\n\n\nAsyncSock.prototype.isConnected = function () {\n  // return this.connection.destroyed && this.connection.writable;\n  return this.connection != null;\n};\n\n\n/* ======================================\n *           Sock handleError\n */\n\nAsyncSock.prototype.handleError = function (err: any) {\n  const self = this;\n  if (self.listeners('error').length > 0) {\n    self.emit('error', err);\n  }\n};\n\n/* ======================================\n *           Sock handleTimeout\n */\n\nAsyncSock.prototype.handleTimeout = function () {\n  const self = this;\n  const conn = self.getConnection();\n  self.emit('timeout'\n    , f('connection %s to %s:%s timed out', conn.id, conn.host, conn.port)\n  );\n\n};\n\n/* ======================================\n *           Sock handleClose\n */\n\nAsyncSock.prototype.handleClose = function (hadError: any) {\n  const self = this;\n  // var conn = self.getConnection()\n  if (!hadError) {\n    self.connection = null;\n    self.emit('close');\n  } else {\n    // ???\n  }\n};\n\n/* ======================================\n *           Sock handleData\n */\n\nAsyncSock.prototype.handleData = function (buffer: any) {\n  const self = this;\n  const response = self.getConnection().messageHandler(buffer, self);\n  self.emit('data', response);\n};\n\n/* ======================================\n *           Sock handleData\n */\n\nAsyncSock.prototype.handleParseError = function (errorObject: any) {\n  const self = this;\n  return self.emit('parseError', errorObject);\n};\n\n/* ======================================\n *           Sock handleConnect\n */\n\nAsyncSock.prototype.handleConnect = function () {\n};\n\n/**\n * Connect\n * @method\n */\nConnection.prototype.connect = function () {\n  this.state = 'connect';\n\n  const args = Array.prototype.slice.call(arguments);\n  let _options = null;\n\n  if (args.length > 0) {\n    if (args.length === 1) {\n      // if first argument is an function then it is an async connection\n      if (typeof args[0] === 'function') {\n        _options = {sync: false};\n        this.on('connect', args[0]);\n      } else {\n        _options = args[0];\n      }\n    }\n  } else {\n    if ('connect' in this.callbacks && this.callbacks['connect'].length > 0) {\n      _options = {sync: false};\n    } else {\n      _options = {sync: true};\n    }\n  }\n\n\n  const self = this;\n  _options = _options || {sync: false};\n  // Check if we are overriding the promoteLongs\n  if (typeof _options.promoteLongs === 'boolean') {\n    self.responseOptions.promoteLongs = _options.promoteLongs;\n  }\n\n  self.isSync = false;\n  // @ts-ignore\n  self.connection = new AsyncSock(self);\n\n  return this;\n};\n\n\n/**\n * Cache callbacks\n * @param eventType\n */\nConnection.prototype.on = function (eventType: any, callback: any) {\n  if (this.connection) {\n    this.connection.on(eventType, callback);\n  } else {\n    this.callbacks[eventType] = this.callbacks[eventType] || [];\n    this.callbacks[eventType].push(callback);\n  }\n\n};\n\n\n/**\n * Destroy connection\n * @method\n */\nConnection.prototype.destroy = function (fn: any) {\n  if (this.connection) {\n    return this.connection.destroy(fn);\n  }\n};\n\n/**\n * Write to connection\n * @method\n * @param {Command} command Command to write out need to implement toBin and toBinUnified\n */\nConnection.prototype.write = function (buffer: any, fn: any) {\n  return this.connection.write(buffer, fn);\n};\n\n\n/**\n * Return id of connection as a string\n * @method\n * @return {string}\n */\nConnection.prototype.toString = function () {\n  return '' + this.id;\n};\n\n/**\n * Return json object of connection\n * @method\n * @return {object}\n */\nConnection.prototype.toJSON = function () {\n  return {id: this.id, host: this.host, port: this.port};\n};\n\n/**\n * Is the connection connected\n * @method\n * @return {boolean}\n */\nConnection.prototype.isConnected = function () {\n  return !this.connection.isConnected();\n};\n\n\nConnection.prototype.destroyAsync = function () {\n  return new Promise((resolve, reject) => {\n    this.destroy((err: any, res: unknown) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n};\nConnection.prototype.connectAsync = function () {\n  return new Promise((resolve, reject) => {\n    this.connect((err: any, res: unknown) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n};\n\nConnection.prototype.writeAsync = function (buffer: any) {\n  return new Promise((resolve, reject) => {\n    this.write(buffer, (err: any, res: unknown) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n};\n"],"sourceRoot":"."}